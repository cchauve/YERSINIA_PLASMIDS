#!/usr/bin/env python

"""
utils.py: Tools to manipulate assembly and assembly graphs in GFA 1 format (http://gfa-spec.github.io/GFA-spec/GFA1.html) used by Unicycler.

Available commands:

1. Convert a GFA SKESA file into the Unicycler format

Usage: utils.py convert_graph --input/-i input_graph --output/-o output_graph [--log/-l log_file]
--input/-i:           path to input assembly graph generated by GFA connector
--output/-o:          path to modified graph, in GFA 1/unicycler format (directories are created if not existing)
--log/-l [optional]:  log file containing statistics on the input and output graph (number of vertices and edges)

Method:
Contigs ad links are filtered to keep only full contigs and links between them, as the SKESA graph has nodes that are subcontigs
For each kept contig, its coverage is defined as the k-mer count (field KC) divided by the contig length
Then the coverage is divided by the median coverage over all kept contigs.
Note: this is only an approximation as for example some extensions are one base long.
"""

__author__ = "Cedric Chauve"

# Built-in/Generic imports
import os
import sys
import argparse
import statistics
from datetime import date

EMPTY_LOG = ''

def convert_graph(input_graph_file, output_graph_file, log_file):
    CTGS, EDGES = {}, []
    CTG_CURRENT_ID = 1
    LOG_STRING = f'# Converting {input_graph_file} into {output_graph_file}\n'
    LOG_STRING += f'# {date.today()}\n'
    NB_CTGS, NB_EXTS, NB_EDGES = 0, 0, 0
    
    # Reading the SKESA graph
    with open(input_graph_file) as input_graph:
        lines = input_graph.readlines()
        for line in lines:
            line_split = line.rstrip().split('\t')
            if line_split[0] == 'S':
                [ctg_id, ctg_seq, kmer_count] = line_split[1:4]
                ctg_id = line_split[1]
                ctg_seq = line_split[2]
                ctg_kcount = line_split[3]
                # Contig coverage = number of k-mers times k-mers length
                ctg_coverage = float(ctg_kcount.split(':')[2]) / len(ctg_seq)
                CTGS[CTG_CURRENT_ID] = {'skesa_id': ctg_id, 'seq': ctg_seq, 'cov': ctg_coverage, 'kcount': ctg_kcount}
                CTG_CURRENT_ID += 1
                if ':' in ctg_id:
                    NB_EXTS += 1
                else:
                    NB_CTGS += 1
            elif line_split[0] == 'L':
                EDGES.append(line_split)
                NB_EDGES += 1
    LOG_STRING += f'nb contigs {NB_CTGS}\n'
    LOG_STRING += f'nb extensions {NB_EXTS}\n'
    LOG_STRING += f'nb links {NB_EDGES}\n'
                
    # Median contigs coverage
    median_coverage = statistics.median([ctg_info['cov'] for ctg_info in CTGS.values()])    
    # Writing the Unicycler-format graph
    with open(output_graph_file, 'w') as output_graph:
        for ctg_info in CTGS.values():
            ctg_seq = ctg_info['seq']
            ctg_len = len(ctg_seq)
            ctg_skesa_id = ctg_info['skesa_id']
            ctg_normalized_cov = ctg_info['cov'] / median_coverage
            ctg_kcount = ctg_info['kcount']
            output_graph.write(f'S\t{ctg_skesa_id}\t{ctg_seq}\tLN:i:{ctg_len}\tdp:f:{ctg_normalized_cov}\t\tKC:i:{ctg_kcount}\n')
        for edge in EDGES:
            output_graph.write(f'{edge[0]}\t{edge[1]}\t{edge[2]}\t{edge[3]}\t{edge[4]}\t{edge[5]}\n')
    # Writing log file
    if log_file != EMPTY_LOG:
        with open(log_file, 'w') as log:
            log.write(LOG_STRING[:-1])
                
if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='plASgraph utils')
    subparser = parser.add_subparsers(dest='command')
    cmd_convert_graph = subparser.add_parser('convert_graph')
    cmd_convert_graph.add_argument('-i', '--input', type=str, required=True, help='Input SKESA GFA file')
    cmd_convert_graph.add_argument('-o', '--output', type=str, required=True, help='Output Unicycler-like GFA file')
    cmd_convert_graph.add_argument('-l', '--log', type=str, required=False, default=EMPTY_LOG, help='Log file')
    args = parser.parse_args()

    if args.command == 'convert_graph':
        convert_graph(args.input, args.output, args.log)
